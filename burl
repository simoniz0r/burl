#!/bin/bash
# Title: burl
# Author: simonizor
# License: MIT
# Dependencies: openssl
# Description: A simple script that makes 'openssl' and bash's '/dev/tcp' easier to use

USE_BASH=0 QUIET=0 METHOD='' HEADER=() INVALID_ARG=()

# function to handle all except POST requests with openssl
req_openssl() {
    printf -v HEADERS '%s\n' "${HEADERS[@]}"
    printf '%s %s HTTP/1.0\nHost: %s\n%s\n' "$METHOD" "$URL" "$HOST" "$HEADERS" |
        openssl s_client -crlf -connect "$HOST":443 -quiet 2>/dev/null
}

# function to handle all except POST requests with bash
req_bash() {
    printf -v HEADERS '%s\r\n' "${HEADERS[@]}"
    exec 9<> /dev/tcp/"$HOST"/80
    printf '%s %s HTTP/1.0\r\nHost: %s\r\n%s\r\n' "$METHOD" "$URL" "$HOST" "$HEADERS" >&9
    cat <&9
}

# function to output help
usage() {
    printf 'burl 0.0.1\n'
    printf "A simple script that makes 'openssl' and bash's '/dev/tcp' easier to use.\n"
    printf 'The default method is openssl\n'
    printf 'Usage:\n'
    printf 'burl [options] <url>\n\n'
    printf 'Options:\n'
    printf "\t-B    \t\tUse bash's /dev/tcp instead of openssl\n\n"
    printf '\t-q, -s\t\tEnable quiet mode\n\n'
    printf '\t-X, -m\t\tSpecify the request command to use (Ex: HEAD, GET, POST)\n\n'
    printf '\t-H    \t\tPass custom header(s) to the server (may be used more than once)\n\n'
}

# detect arguments
while (($#)); do
    case "$1" in
        # output help and break
        --help|-h) usage; exit 0;;
        # parse shortopts using burl_argparse function
        -[a-zA-Z]*)
            for ((i = 1; i < ${#1}; i++)); do
                case "${1:i:1}" in
                    # use bash /dev/tcp
                    B) USE_BASH=1;;
                    # quiet mode
                    q|s) QUIET=1;;
                    # request method, set METHOD to uppercase of argument
                    X|m)
                        # if there is more in arg after opt make that optarg
                        if [[ -n "${1:i+1}" ]]; then
                            METHOD="${1:i+1}" METHOD="${METHOD^^}"
                        # otherwise make next argument optarg
                        else
                            METHOD="${2^^}"
                            shift
                        fi
                        break
                        ;;
                    # set headers, add following input to HEADERS array
                    H)
                        # if there is more in arg after opt make that optarg
                        if [[ -n "${1:i+1}" ]]; then
                            HEADERS+=("${1:i+1}") HEADERS[-1]="${HEADERS[-1]^^}"
                        # otherwise make next argument optarg
                        else
                            HEADERS+=("${2^^}")
                            shift
                        fi
                        break
                        ;;
                esac
            done
            ;;
        # no longopts yet so add to invalid args array
        --*) INVALID_ARG+=("$1");;
        # assume any other input is the url to be used
        *) URL="$1";;
    esac
    shift
done

# if invalid arguments passed, show them and exit
if [[ -n "${INVALID_ARG[*]}" ]]; then
    IFS=',' # make INVALID_ARG expand comma delimited
    echo "Invalid argument(s) passed: ${INVALID_ARG[*]}" >&2
    echo "See '--help' for usage." >&2
    exit 1
fi

# set curl user agent if user agent not set
if [[ "${HEADERS[*]}" != *'User-Agent:'* ]]; then
    HEADERS+=("User-Agent: curl/7.64.0")
fi

# if METHOD is HEAD, disable quiet mode, and if it isn't set, use GET
if [[ "${METHOD:=GET}" = 'HEAD' ]]; then
    QUIET=0
fi

# if missing url, output help
if [[ -z "$URL" ]]; then
    echo "Missing url.  See '--help' for usage." >&2
    exit 1
fi

# get host domain from full URL
HOST="${URL#*/*/}" HOST="${HOST%%/*}"
if ((USE_BASH)); then
    REQ='req_bash'
else
    REQ='req_openssl'
fi

# if QUIET is 1, get rid of header info
if ((QUIET)); then
    mapfile OUTPUT < <("${REQ}")
    for i in "${!OUTPUT[@]}"; do
        # print everything after the first line with only CRLF
        [[ "${OUTPUT[i]}" = $'\r\n' ]] && break
        unset 'OUTPUT[i]'
    done
    printf '%s' "${OUTPUT[@]:i+1}"
else
    "${REQ}"
fi
